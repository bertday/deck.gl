"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[7838],{3905:(t,e,i)=>{i.d(e,{Zo:()=>u,kt:()=>p});var n=i(67294);function o(t,e,i){return e in t?Object.defineProperty(t,e,{value:i,enumerable:!0,configurable:!0,writable:!0}):t[e]=i,t}function r(t,e){var i=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),i.push.apply(i,n)}return i}function l(t){for(var e=1;e<arguments.length;e++){var i=null!=arguments[e]?arguments[e]:{};e%2?r(Object(i),!0).forEach((function(e){o(t,e,i[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(i)):r(Object(i)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(i,e))}))}return t}function s(t,e){if(null==t)return{};var i,n,o=function(t,e){if(null==t)return{};var i,n,o={},r=Object.keys(t);for(n=0;n<r.length;n++)i=r[n],e.indexOf(i)>=0||(o[i]=t[i]);return o}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(n=0;n<r.length;n++)i=r[n],e.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(t,i)&&(o[i]=t[i])}return o}var a=n.createContext({}),c=function(t){var e=n.useContext(a),i=e;return t&&(i="function"==typeof t?t(e):l(l({},e),t)),i},u=function(t){var e=c(t.components);return n.createElement(a.Provider,{value:e},t.children)},h="mdxType",g={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},d=n.forwardRef((function(t,e){var i=t.components,o=t.mdxType,r=t.originalType,a=t.parentName,u=s(t,["components","mdxType","originalType","parentName"]),h=c(i),d=o,p=h["".concat(a,".").concat(d)]||h[d]||g[d]||r;return i?n.createElement(p,l(l({ref:e},u),{},{components:i})):n.createElement(p,l({ref:e},u))}));function p(t,e){var i=arguments,o=e&&e.mdxType;if("string"==typeof t||o){var r=i.length,l=new Array(r);l[0]=d;var s={};for(var a in e)hasOwnProperty.call(e,a)&&(s[a]=e[a]);s.originalType=t,s[h]="string"==typeof t?t:o,l[1]=s;for(var c=2;c<r;c++)l[c]=i[c];return n.createElement.apply(null,l)}return n.createElement.apply(null,i)}d.displayName="MDXCreateElement"},85162:(t,e,i)=>{i.d(e,{Z:()=>l});var n=i(67294),o=i(86010);const r={tabItem:"tabItem_Ymn6"};function l(t){let{children:e,hidden:i,className:l}=t;return n.createElement("div",{role:"tabpanel",className:(0,o.Z)(r.tabItem,l),hidden:i},e)}},74866:(t,e,i)=>{i.d(e,{Z:()=>y});var n=i(87462),o=i(67294),r=i(86010),l=i(12466),s=i(16550),a=i(91980),c=i(67392),u=i(50012);function h(t){return function(t){return o.Children.map(t,(t=>{if((0,o.isValidElement)(t)&&"value"in t.props)return t;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof t.type?t.type:t.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')}))}(t).map((t=>{let{props:{value:e,label:i,attributes:n,default:o}}=t;return{value:e,label:i,attributes:n,default:o}}))}function g(t){const{values:e,children:i}=t;return(0,o.useMemo)((()=>{const t=null!=e?e:h(i);return function(t){const e=(0,c.l)(t,((t,e)=>t.value===e.value));if(e.length>0)throw new Error('Docusaurus error: Duplicate values "'+e.map((t=>t.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(t),t}),[e,i])}function d(t){let{value:e,tabValues:i}=t;return i.some((t=>t.value===e))}function p(t){let{queryString:e=!1,groupId:i}=t;const n=(0,s.k6)(),r=function(t){let{queryString:e=!1,groupId:i}=t;if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!i)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=i?i:null}({queryString:e,groupId:i});return[(0,a._X)(r),(0,o.useCallback)((t=>{if(!r)return;const e=new URLSearchParams(n.location.search);e.set(r,t),n.replace({...n.location,search:e.toString()})}),[r,n])]}function f(t){const{defaultValue:e,queryString:i=!1,groupId:n}=t,r=g(t),[l,s]=(0,o.useState)((()=>function(t){var e;let{defaultValue:i,tabValues:n}=t;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(i){if(!d({value:i,tabValues:n}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+i+'" but none of its children has the corresponding value. Available values are: '+n.map((t=>t.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return i}const o=null!=(e=n.find((t=>t.default)))?e:n[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:e,tabValues:r}))),[a,c]=p({queryString:i,groupId:n}),[h,f]=function(t){let{groupId:e}=t;const i=function(t){return t?"docusaurus.tab."+t:null}(e),[n,r]=(0,u.Nk)(i);return[n,(0,o.useCallback)((t=>{i&&r.set(t)}),[i,r])]}({groupId:n}),m=(()=>{const t=null!=a?a:h;return d({value:t,tabValues:r})?t:null})();(0,o.useLayoutEffect)((()=>{m&&s(m)}),[m]);return{selectedValue:l,selectValue:(0,o.useCallback)((t=>{if(!d({value:t,tabValues:r}))throw new Error("Can't select invalid tab value="+t);s(t),c(t),f(t)}),[c,f,r]),tabValues:r}}var m=i(72389);const v={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function b(t){let{className:e,block:i,selectedValue:s,selectValue:a,tabValues:c}=t;const u=[],{blockElementScrollPositionUntilNextRender:h}=(0,l.o5)(),g=t=>{const e=t.currentTarget,i=u.indexOf(e),n=c[i].value;n!==s&&(h(e),a(n))},d=t=>{var e;let i=null;switch(t.key){case"Enter":g(t);break;case"ArrowRight":{var n;const e=u.indexOf(t.currentTarget)+1;i=null!=(n=u[e])?n:u[0];break}case"ArrowLeft":{var o;const e=u.indexOf(t.currentTarget)-1;i=null!=(o=u[e])?o:u[u.length-1];break}}null==(e=i)||e.focus()};return o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":i},e)},c.map((t=>{let{value:e,label:i,attributes:l}=t;return o.createElement("li",(0,n.Z)({role:"tab",tabIndex:s===e?0:-1,"aria-selected":s===e,key:e,ref:t=>u.push(t),onKeyDown:d,onClick:g},l,{className:(0,r.Z)("tabs__item",v.tabItem,null==l?void 0:l.className,{"tabs__item--active":s===e})}),null!=i?i:e)})))}function _(t){let{lazy:e,children:i,selectedValue:n}=t;if(i=Array.isArray(i)?i:[i],e){const t=i.find((t=>t.props.value===n));return t?(0,o.cloneElement)(t,{className:"margin-top--md"}):null}return o.createElement("div",{className:"margin-top--md"},i.map(((t,e)=>(0,o.cloneElement)(t,{key:e,hidden:t.props.value!==n}))))}function C(t){const e=f(t);return o.createElement("div",{className:(0,r.Z)("tabs-container",v.tabList)},o.createElement(b,(0,n.Z)({},t,e)),o.createElement(_,(0,n.Z)({},t,e)))}function y(t){const e=(0,m.Z)();return o.createElement(C,(0,n.Z)({key:String(e)},t))}},24808:(t,e,i)=>{i.d(e,{D5:()=>l});var n=i(67294),o=i(83156);i(9547),i(38826),i(81255),i(37442),i(4432),i(6415),i(90552),i(33855),i(46176),i(38824),i(31592);const r=i.e(4613).then(i.t.bind(i,24613,23)),l=n.forwardRef((function(t,e){return(0,o.Z)(t,e,r)}))},78542:(t,e,i)=>{function n(t){let e=1/0,i=1/0,n=1/0,o=-1/0,r=-1/0,l=-1/0;const s=t.POSITION?t.POSITION.value:[],a=s&&s.length;for(let c=0;c<a;c+=3){const t=s[c],a=s[c+1],u=s[c+2];e=t<e?t:e,i=a<i?a:i,n=u<n?u:n,o=t>o?t:o,r=a>r?a:r,l=u>l?u:l}return[[e,i,n],[o,r,l]]}i.d(e,{v:()=>n})},41708:(t,e,i)=>{i.d(e,{Z:()=>r});var n=i(60326),o=i(67532);class r{id;topology;vertexCount;indices;attributes;userData={};constructor(t){const{attributes:e={},indices:i=null,vertexCount:r=null}=t;this.id=t.id||(0,n.h)("geometry"),this.topology=t.topology,i&&(this.indices=ArrayBuffer.isView(i)?{value:i,size:1}:i),this.attributes={};for(const[n,l]of Object.entries(e)){const t=ArrayBuffer.isView(l)?{value:l}:l;(0,o.h)(ArrayBuffer.isView(t.value),`${this._print(n)}: must be typed array or object with value as typed array`),"POSITION"!==n&&"positions"!==n||t.size||(t.size=3),"indices"===n?((0,o.h)(!this.indices),this.indices=t):this.attributes[n]=t}this.indices&&void 0!==this.indices.isIndexed&&(this.indices=Object.assign({},this.indices),delete this.indices.isIndexed),this.vertexCount=r||this._calculateVertexCount(this.attributes,this.indices)}getVertexCount(){return this.vertexCount}getAttributes(){return this.indices?{indices:this.indices,...this.attributes}:this.attributes}_print(t){return`Geometry ${this.id} attribute ${t}`}_setAttributes(t,e){return this}_calculateVertexCount(t,e){if(e)return e.value.length;let i=1/0;for(const n of Object.values(t)){const{value:t,size:e,constant:o}=n;!o&&t&&e>=1&&(i=Math.min(i,t.length/e))}return(0,o.h)(Number.isFinite(i)),i}}},42013:(t,e,i)=>{i.d(e,{H:()=>l});const n="#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\nstruct AmbientLight {\nvec3 color;\n};\nstruct PointLight {\nvec3 color;\nvec3 position;\nvec3 attenuation;\n};\nstruct DirectionalLight {\nvec3 color;\nvec3 direction;\n};\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\nuniform bool lighting_uEnabled;\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\nreturn pointLight.attenuation.x\n+ pointLight.attenuation.y * distance\n+ pointLight.attenuation.z * distance * distance;\n}\n#endif\n",o={lightSources:{}};function r(t={}){const{color:e=[0,0,0],intensity:i=1}=t;return e.map((t=>t*i/255))}const l={name:"lights",vs:n,fs:n,getUniforms:function t(e=o){if("lightSources"in e){const{ambientLight:t,pointLights:i,directionalLights:n}=e.lightSources||{};return t||i&&i.length>0||n&&n.length>0?Object.assign({},function({ambientLight:t,pointLights:e=[],directionalLights:i=[]}){const n={};return n["lighting_uAmbientLight.color"]=t?r(t):[0,0,0],e.forEach(((t,e)=>{n[`lighting_uPointLight[${e}].color`]=r(t),n[`lighting_uPointLight[${e}].position`]=t.position,n[`lighting_uPointLight[${e}].attenuation`]=t.attenuation||[1,0,0]})),n.lighting_uPointLightCount=e.length,i.forEach(((t,e)=>{n[`lighting_uDirectionalLight[${e}].color`]=r(t),n[`lighting_uDirectionalLight[${e}].direction`]=t.direction})),n.lighting_uDirectionalLightCount=i.length,n}({ambientLight:t,pointLights:i,directionalLights:n}),{lighting_uEnabled:!0}):{lighting_uEnabled:!1}}if("lights"in e){const i={pointLights:[],directionalLights:[]};for(const t of e.lights||[])switch(t.type){case"ambient":i.ambientLight=t;break;case"directional":i.directionalLights?.push(t);break;case"point":i.pointLights?.push(t)}return t({lightSources:i})}return{}},defines:{MAX_LIGHTS:3}}},55098:(t,e,i)=>{i.d(e,{N:()=>s,s:()=>a});var n=i(42013);const o="uniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\nvec3 halfway_direction = normalize(light_direction + view_direction);\nfloat lambertian = dot(light_direction, normal_worldspace);\nfloat specular = 0.0;\nif (lambertian > 0.0) {\nfloat specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\nspecular = pow(specular_angle, lighting_uShininess);\n}\nlambertian = max(lambertian, 0.0);\nreturn (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\nvec3 lightColor = surfaceColor;\nif (lighting_uEnabled) {\nvec3 view_direction = normalize(cameraPosition - position_worldspace);\nlightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\nfor (int i = 0; i < MAX_LIGHTS; i++) {\nif (i >= lighting_uPointLightCount) {\nbreak;\n}\nPointLight pointLight = lighting_uPointLight[i];\nvec3 light_position_worldspace = pointLight.position;\nvec3 light_direction = normalize(light_position_worldspace - position_worldspace);\nlightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n}\nfor (int i = 0; i < MAX_LIGHTS; i++) {\nif (i >= lighting_uDirectionalLightCount) {\nbreak;\n}\nDirectionalLight directionalLight = lighting_uDirectionalLight[i];\nlightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n}\n}\nreturn lightColor;\n}\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\nvec3 lightColor = vec3(0, 0, 0);\nvec3 surfaceColor = vec3(0, 0, 0);\nif (lighting_uEnabled) {\nvec3 view_direction = normalize(cameraPosition - position_worldspace);\nfor (int i = 0; i < MAX_LIGHTS; i++) {\nif (i >= lighting_uPointLightCount) {\nbreak;\n}\nPointLight pointLight = lighting_uPointLight[i];\nvec3 light_position_worldspace = pointLight.position;\nvec3 light_direction = normalize(light_position_worldspace - position_worldspace);\nlightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n}\nfor (int i = 0; i < MAX_LIGHTS; i++) {\nif (i >= lighting_uDirectionalLightCount) {\nbreak;\n}\nDirectionalLight directionalLight = lighting_uDirectionalLight[i];\nlightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n}\n}\nreturn lightColor;\n}\n",r={};function l(t=r){if(!("material"in t))return{};const{material:e}=t;return e?function(t){const{ambient:e=.35,diffuse:i=.6,shininess:n=32,specularColor:o=[30,30,30]}=t;return{lighting_uAmbient:e,lighting_uDiffuse:i,lighting_uShininess:n,lighting_uSpecularColor:o.map((t=>t/255))}}(e):{lighting_uEnabled:!1}}const s={name:"gouraud-lighting",dependencies:[n.H],vs:o,defines:{LIGHTING_VERTEX:1},getUniforms:l},a={name:"phong-lighting",dependencies:[n.H],fs:o,defines:{LIGHTING_FRAGMENT:1},getUniforms:l}},35300:(t,e,i)=>{i.d(e,{q:()=>n});const n={name:"picking",vs:"uniform pickingUniforms {\nfloat isActive;\nfloat isAttribute;\nfloat isHighlightActive;\nfloat useFloatColors;\nvec3 highlightedObjectColor;\nvec4 highlightColor;\n} picking;\nout vec4 picking_vRGBcolor_Avalid;\nvec3 picking_normalizeColor(vec3 color) {\nreturn picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\nvec4 picking_normalizeColor(vec4 color) {\nreturn picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\nbool picking_isColorZero(vec3 color) {\nreturn dot(color, vec3(1.0)) < 0.00001;\n}\nbool picking_isColorValid(vec3 color) {\nreturn dot(color, vec3(1.0)) > 0.00001;\n}\nbool isVertexHighlighted(vec3 vertexColor) {\nvec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);\nreturn\nbool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));\n}\nvoid picking_setPickingColor(vec3 pickingColor) {\npickingColor = picking_normalizeColor(pickingColor);\nif (bool(picking.isActive)) {\npicking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\nif (!bool(picking.isAttribute)) {\npicking_vRGBcolor_Avalid.rgb = pickingColor;\n}\n} else {\npicking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));\n}\n}\nvoid picking_setPickingAttribute(float value) {\nif (bool(picking.isAttribute)) {\npicking_vRGBcolor_Avalid.r = value;\n}\n}\nvoid picking_setPickingAttribute(vec2 value) {\nif (bool(picking.isAttribute)) {\npicking_vRGBcolor_Avalid.rg = value;\n}\n}\nvoid picking_setPickingAttribute(vec3 value) {\nif (bool(picking.isAttribute)) {\npicking_vRGBcolor_Avalid.rgb = value;\n}\n}\n",fs:"uniform pickingUniforms {\nfloat isActive;\nfloat isAttribute;\nfloat isHighlightActive;\nfloat useFloatColors;\nvec3 highlightedObjectColor;\nvec4 highlightColor;\n} picking;\nin vec4 picking_vRGBcolor_Avalid;\nvec4 picking_filterHighlightColor(vec4 color) {\nif (picking.isActive > 0.5) {\nreturn color;\n}\nbool selected = bool(picking_vRGBcolor_Avalid.a);\nif (selected) {\nfloat highLightAlpha = picking.highlightColor.a;\nfloat blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\nfloat highLightRatio = highLightAlpha / blendedAlpha;\nvec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);\nreturn vec4(blendedRGB, blendedAlpha);\n} else {\nreturn color;\n}\n}\nvec4 picking_filterPickingColor(vec4 color) {\nif (bool(picking.isActive)) {\nif (picking_vRGBcolor_Avalid.a == 0.0) {\ndiscard;\n}\nreturn picking_vRGBcolor_Avalid;\n}\nreturn color;\n}\nvec4 picking_filterColor(vec4 color) {\nvec4 highlightColor = picking_filterHighlightColor(color);\nreturn picking_filterPickingColor(highlightColor);\n}\n",uniformTypes:{isActive:"f32",isAttribute:"f32",isHighlightActive:"f32",useFloatColors:"f32",highlightedObjectColor:"vec3<f32>",highlightColor:"vec4<f32>"},defaultUniforms:{isActive:!1,isAttribute:!1,isHighlightActive:!1,useFloatColors:!0,highlightedObjectColor:[0,0,0],highlightColor:[0,1,1,1]},getUniforms:function(t={},e){const i={};if(void 0===t.highlightedObjectColor);else if(null===t.highlightedObjectColor)i.isHighlightActive=!1;else{i.isHighlightActive=!0;const e=t.highlightedObjectColor.slice(0,3);i.highlightedObjectColor=e}if(t.highlightColor){const e=Array.from(t.highlightColor,(t=>t/255));Number.isFinite(e[3])||(e[3]=1),i.highlightColor=e}void 0!==t.isActive&&(i.isActive=Boolean(t.isActive),i.isAttribute=Boolean(t.isAttribute));void 0!==t.useFloatColors&&(i.useFloatColors=Boolean(t.useFloatColors));return i}}},25825:(t,e,i)=>{i.d(e,{LU:()=>m});var n=i(78542);const o=/^[og]\s*(.+)?/,r=/^mtllib /,l=/^usemtl /;class s{constructor({index:t,name:e="",mtllib:i,smooth:n,groupStart:o}){this.index=t,this.name=e,this.mtllib=i,this.smooth=n,this.groupStart=o,this.groupEnd=-1,this.groupCount=-1,this.inherited=!1}clone(t=this.index){return new s({index:t,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0})}}class a{constructor(t=""){this.name=t,this.geometry={vertices:[],normals:[],colors:[],uvs:[]},this.materials=[],this.smooth=!0,this.fromDeclaration=null}startMaterial(t,e){const i=this._finalize(!1);i&&(i.inherited||i.groupCount<=0)&&this.materials.splice(i.index,1);const n=new s({index:this.materials.length,name:t,mtllib:Array.isArray(e)&&e.length>0?e[e.length-1]:"",smooth:void 0!==i?i.smooth:this.smooth,groupStart:void 0!==i?i.groupEnd:0});return this.materials.push(n),n}currentMaterial(){if(this.materials.length>0)return this.materials[this.materials.length-1]}_finalize(t){const e=this.currentMaterial();if(e&&-1===e.groupEnd&&(e.groupEnd=this.geometry.vertices.length/3,e.groupCount=e.groupEnd-e.groupStart,e.inherited=!1),t&&this.materials.length>1)for(let i=this.materials.length-1;i>=0;i--)this.materials[i].groupCount<=0&&this.materials.splice(i,1);return t&&0===this.materials.length&&this.materials.push({name:"",smooth:this.smooth}),e}}class c{constructor(){this.objects=[],this.object=null,this.vertices=[],this.normals=[],this.colors=[],this.uvs=[],this.materialLibraries=[],this.startObject("",!1)}startObject(t,e=!0){if(this.object&&!this.object.fromDeclaration)return this.object.name=t,void(this.object.fromDeclaration=e);const i=this.object&&"function"==typeof this.object.currentMaterial?this.object.currentMaterial():void 0;if(this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0),this.object=new a(t),this.object.fromDeclaration=e,i&&i.name&&"function"==typeof i.clone){const t=i.clone(0);t.inherited=!0,this.object.materials.push(t)}this.objects.push(this.object)}finalize(){this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0)}parseVertexIndex(t,e){const i=parseInt(t);return 3*(i>=0?i-1:i+e/3)}parseNormalIndex(t,e){const i=parseInt(t);return 3*(i>=0?i-1:i+e/3)}parseUVIndex(t,e){const i=parseInt(t);return 2*(i>=0?i-1:i+e/2)}addVertex(t,e,i){const n=this.vertices,o=this.object.geometry.vertices;o.push(n[t+0],n[t+1],n[t+2]),o.push(n[e+0],n[e+1],n[e+2]),o.push(n[i+0],n[i+1],n[i+2])}addVertexPoint(t){const e=this.vertices;this.object.geometry.vertices.push(e[t+0],e[t+1],e[t+2])}addVertexLine(t){const e=this.vertices;this.object.geometry.vertices.push(e[t+0],e[t+1],e[t+2])}addNormal(t,e,i){const n=this.normals,o=this.object.geometry.normals;o.push(n[t+0],n[t+1],n[t+2]),o.push(n[e+0],n[e+1],n[e+2]),o.push(n[i+0],n[i+1],n[i+2])}addColor(t,e,i){const n=this.colors,o=this.object.geometry.colors;o.push(n[t+0],n[t+1],n[t+2]),o.push(n[e+0],n[e+1],n[e+2]),o.push(n[i+0],n[i+1],n[i+2])}addUV(t,e,i){const n=this.uvs,o=this.object.geometry.uvs;o.push(n[t+0],n[t+1]),o.push(n[e+0],n[e+1]),o.push(n[i+0],n[i+1])}addUVLine(t){const e=this.uvs;this.object.geometry.uvs.push(e[t+0],e[t+1])}addFace(t,e,i,n,o,r,l,s,a){const c=this.vertices.length;let u=this.parseVertexIndex(t,c),h=this.parseVertexIndex(e,c),g=this.parseVertexIndex(i,c);if(this.addVertex(u,h,g),void 0!==n&&""!==n){const t=this.uvs.length;u=this.parseUVIndex(n,t),h=this.parseUVIndex(o,t),g=this.parseUVIndex(r,t),this.addUV(u,h,g)}if(void 0!==l&&""!==l){const t=this.normals.length;u=this.parseNormalIndex(l,t),h=l===s?u:this.parseNormalIndex(s,t),g=l===a?u:this.parseNormalIndex(a,t),this.addNormal(u,h,g)}this.colors.length>0&&this.addColor(u,h,g)}addPointGeometry(t){this.object.geometry.type="Points";const e=this.vertices.length;for(const i of t)this.addVertexPoint(this.parseVertexIndex(i,e))}addLineGeometry(t,e){this.object.geometry.type="Line";const i=this.vertices.length,n=this.uvs.length;for(const o of t)this.addVertexLine(this.parseVertexIndex(o,i));for(const o of e)this.addUVLine(this.parseUVIndex(o,n))}}var u=i(75177);function h(t,e){const i={};for(const o in e)"value"!==o&&(i[o]=JSON.stringify(e[o]));let{type:n}=(0,u.gU)(e.value);return 1===e.size||void 0===e.size||(n={type:"fixed-size-list",listSize:e.size,children:[{name:"values",type:n}]}),{name:t,type:n,nullable:!1,metadata:i}}function g(t,e){const{meshes:i}=function(t){const e=new c;-1!==t.indexOf("\r\n")&&(t=t.replace(/\r\n/g,"\n")),-1!==t.indexOf("\\\n")&&(t=t.replace(/\\\n/g,""));const i=t.split("\n");let n="",s="",a=0,u=[];const h="function"==typeof"".trimLeft;for(let c=0,p=i.length;c<p;c++)if(n=i[c],n=h?n.trimLeft():n.trim(),a=n.length,0!==a&&(s=n.charAt(0),"#"!==s))if("v"===s){const t=n.split(/\s+/);switch(t[0]){case"v":e.vertices.push(parseFloat(t[1]),parseFloat(t[2]),parseFloat(t[3])),t.length>=7&&e.colors.push(parseFloat(t[4]),parseFloat(t[5]),parseFloat(t[6]));break;case"vn":e.normals.push(parseFloat(t[1]),parseFloat(t[2]),parseFloat(t[3]));break;case"vt":e.uvs.push(parseFloat(t[1]),parseFloat(t[2]))}}else if("f"===s){const t=n.substr(1).trim().split(/\s+/),i=[];for(let e=0,n=t.length;e<n;e++){const n=t[e];if(n.length>0){const t=n.split("/");i.push(t)}}const o=i[0];for(let n=1,r=i.length-1;n<r;n++){const t=i[n],r=i[n+1];e.addFace(o[0],t[0],r[0],o[1],t[1],r[1],o[2],t[2],r[2])}}else if("l"===s){const t=n.substring(1).trim().split(" ");let i;const o=[];if(-1===n.indexOf("/"))i=t;else{i=[];for(let e=0,n=t.length;e<n;e++){const n=t[e].split("/");""!==n[0]&&i.push(n[0]),""!==n[1]&&o.push(n[1])}}e.addLineGeometry(i,o)}else if("p"===s){const t=n.substr(1).trim().split(" ");e.addPointGeometry(t)}else if(null!==(u=o.exec(n))){const t=(" "+u[0].substr(1).trim()).substr(1);e.startObject(t)}else if(l.test(n))e.object.startMaterial(n.substring(7).trim(),e.materialLibraries);else if(r.test(n))e.materialLibraries.push(n.substring(7).trim());else{if("s"!==s){if("\0"===n)continue;throw new Error(`Unexpected line: "${n}"`)}{if(u=n.split(" "),u.length>1){const t=u[1].trim().toLowerCase();e.object.smooth="0"!==t&&"off"!==t}else e.object.smooth=!0;const t=e.object.currentMaterial();t&&(t.smooth=e.object.smooth)}}e.finalize();const g=[],d=[];for(const o of e.objects){const{geometry:t}=o;if(0===t.vertices.length)continue;const e={header:{vertexCount:t.vertices.length/3},attributes:{}};switch(t.type){case"Points":e.mode=0;break;case"Line":e.mode=1;break;default:e.mode=4}e.attributes.POSITION={value:new Float32Array(t.vertices),size:3},t.normals.length>0&&(e.attributes.NORMAL={value:new Float32Array(t.normals),size:3}),t.colors.length>0&&(e.attributes.COLOR_0={value:new Float32Array(t.colors),size:3}),t.uvs.length>0&&(e.attributes.TEXCOORD_0={value:new Float32Array(t.uvs),size:2}),e.materials=[];for(const i of o.materials){const t={name:i.name,flatShading:!i.smooth};e.materials.push(t),d.push(t)}e.name=o.name,g.push(e)}return{meshes:g,materials:d}}(t),s=i.reduce(((t,e)=>t+e.header.vertexCount),0),a=function(t,e){const i=new Float32Array(3*e);let n,o,r,l=0;for(const a of t){const{POSITION:t,NORMAL:s,COLOR_0:c,TEXCOORD_0:u}=a.attributes;i.set(t.value,3*l),s&&(n=n||new Float32Array(3*e),n.set(s.value,3*l)),c&&(o=o||new Float32Array(3*e),o.set(c.value,3*l)),u&&(r=r||new Float32Array(2*e),r.set(u.value,2*l)),l+=t.value.length/3}const s={};s.POSITION={value:i,size:3},n&&(s.NORMAL={value:n,size:3});o&&(s.COLOR_0={value:o,size:3});r&&(s.TEXCOORD_0={value:r,size:2});return s}(i,s),u={vertexCount:s,boundingBox:(0,n.v)(a)},g=function(t,e={}){const i={};for(const o in e)"value"!==o&&(i[o]=JSON.stringify(e[o]));const n=[];for(const o in t){const e=h(o,t[o]);n.push(e)}return{fields:n,metadata:i}}(a,{mode:4,boundingBox:u.boundingBox});return{loaderData:{header:{}},schema:g,header:u,mode:4,topology:"point-list",attributes:a}}const d=/\s+/;function p(t,e){const i=[];let n={name:"placeholder"};const o=t.split("\n");for(let r of o){if(r=r.trim(),0===r.length||"#"===r.charAt(0))continue;const t=r.indexOf(" ");let e=t>=0?r.substring(0,t):r;e=e.toLowerCase();let o=t>=0?r.substring(t+1):"";switch(o=o.trim(),e){case"newmtl":n={name:o},i.push(n);break;case"ka":n.ambientColor=f(o);break;case"kd":n.diffuseColor=f(o);break;case"map_kd":n.diffuseTextureUrl=o;break;case"ks":n.specularColor=f(o);break;case"map_ks":n.specularTextureUrl=o;break;case"ke":n.emissiveColor=f(o);break;case"map_ke":n.emissiveTextureUrl=o;break;case"ns":n.shininess=parseFloat(o);break;case"map_ns":default:break;case"ni":n.refraction=parseFloat(o);break;case"illum":n.illumination=parseFloat(o)}}return i}function f(t,e){const i=t.split(d,3);return[parseFloat(i[0]),parseFloat(i[1]),parseFloat(i[2])]}const m={...{dataType:null,batchType:null,name:"OBJ",id:"obj",module:"obj",version:"4.3.2",worker:!0,extensions:["obj"],mimeTypes:["text/plain"],testText:function(t){return"v"===t[0]},options:{obj:{}}},parse:async(t,e)=>g((new TextDecoder).decode(t)),parseTextSync:(t,e)=>g(t)}}}]);