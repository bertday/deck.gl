"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[5857],{19365:(e,t,i)=>{i.d(t,{A:()=>s});i(96540);var n=i(34164);const r={tabItem:"tabItem_Ymn6"};var o=i(74848);function s(e){let{children:t,hidden:i,className:s}=e;return(0,o.jsx)("div",{role:"tabpanel",className:(0,n.A)(r.tabItem,s),hidden:i,children:t})}},11470:(e,t,i)=>{i.d(t,{A:()=>x});var n=i(96540),r=i(34164),o=i(23104),s=i(56347),a=i(205),l=i(57485),c=i(31682),u=i(70679);function h(e){var t,i;return null!=(t=null==(i=n.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,n.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})))?void 0:i.filter(Boolean))?t:[]}function d(e){const{values:t,children:i}=e;return(0,n.useMemo)((()=>{const e=null!=t?t:function(e){return h(e).map((e=>{let{props:{value:t,label:i,attributes:n,default:r}}=e;return{value:t,label:i,attributes:n,default:r}}))}(i);return function(e){const t=(0,c.XI)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error('Docusaurus error: Duplicate values "'+t.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[t,i])}function p(e){let{value:t,tabValues:i}=e;return i.some((e=>e.value===t))}function g(e){let{queryString:t=!1,groupId:i}=e;const r=(0,s.W6)(),o=function(e){let{queryString:t=!1,groupId:i}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!i)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=i?i:null}({queryString:t,groupId:i});return[(0,l.aZ)(o),(0,n.useCallback)((e=>{if(!o)return;const t=new URLSearchParams(r.location.search);t.set(o,e),r.replace(Object.assign({},r.location,{search:t.toString()}))}),[o,r])]}function f(e){const{defaultValue:t,queryString:i=!1,groupId:r}=e,o=d(e),[s,l]=(0,n.useState)((()=>function(e){var t;let{defaultValue:i,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(i){if(!p({value:i,tabValues:n}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+i+'" but none of its children has the corresponding value. Available values are: '+n.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return i}const r=null!=(t=n.find((e=>e.default)))?t:n[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:t,tabValues:o}))),[c,h]=g({queryString:i,groupId:r}),[f,m]=function(e){let{groupId:t}=e;const i=function(e){return e?"docusaurus.tab."+e:null}(t),[r,o]=(0,u.Dv)(i);return[r,(0,n.useCallback)((e=>{i&&o.set(e)}),[i,o])]}({groupId:r}),b=(()=>{const e=null!=c?c:f;return p({value:e,tabValues:o})?e:null})();(0,a.A)((()=>{b&&l(b)}),[b]);return{selectedValue:s,selectValue:(0,n.useCallback)((e=>{if(!p({value:e,tabValues:o}))throw new Error("Can't select invalid tab value="+e);l(e),h(e),m(e)}),[h,m,o]),tabValues:o}}var m=i(92303);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var v=i(74848);function _(e){let{className:t,block:i,selectedValue:n,selectValue:s,tabValues:a}=e;const l=[],{blockElementScrollPositionUntilNextRender:c}=(0,o.a_)(),u=e=>{const t=e.currentTarget,i=l.indexOf(t),r=a[i].value;r!==n&&(c(t),s(r))},h=e=>{var t;let i=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{var n;const t=l.indexOf(e.currentTarget)+1;i=null!=(n=l[t])?n:l[0];break}case"ArrowLeft":{var r;const t=l.indexOf(e.currentTarget)-1;i=null!=(r=l[t])?r:l[l.length-1];break}}null==(t=i)||t.focus()};return(0,v.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":i},t),children:a.map((e=>{let{value:t,label:i,attributes:o}=e;return(0,v.jsx)("li",Object.assign({role:"tab",tabIndex:n===t?0:-1,"aria-selected":n===t,ref:e=>l.push(e),onKeyDown:h,onClick:u},o,{className:(0,r.A)("tabs__item",b.tabItem,null==o?void 0:o.className,{"tabs__item--active":n===t}),children:null!=i?i:t}),t)}))})}function w(e){let{lazy:t,children:i,selectedValue:o}=e;const s=(Array.isArray(i)?i:[i]).filter(Boolean);if(t){const e=s.find((e=>e.props.value===o));return e?(0,n.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,v.jsx)("div",{className:"margin-top--md",children:s.map(((e,t)=>(0,n.cloneElement)(e,{key:t,hidden:e.props.value!==o})))})}function y(e){const t=f(e);return(0,v.jsxs)("div",{className:(0,r.A)("tabs-container",b.tabList),children:[(0,v.jsx)(_,Object.assign({},t,e)),(0,v.jsx)(w,Object.assign({},t,e))]})}function x(e){const t=(0,m.A)();return(0,v.jsx)(y,Object.assign({},e,{children:h(e.children)}),String(t))}},35983:(e,t,i)=>{function n(e){let t=1/0,i=1/0,n=1/0,r=-1/0,o=-1/0,s=-1/0;const a=e.POSITION?e.POSITION.value:[],l=a&&a.length;for(let c=0;c<l;c+=3){const e=a[c],l=a[c+1],u=a[c+2];t=e<t?e:t,i=l<i?l:i,n=u<n?u:n,r=e>r?e:r,o=l>o?l:o,s=u>s?u:s}return[[t,i,n],[r,o,s]]}i.d(t,{l:()=>n})},72404:(e,t,i)=>{i.d(t,{w:()=>o});var n=i(10513);var r=i(38846);const o={name:"phongMaterial",dependencies:[n.x],source:"struct phongMaterialUniforms {\n  ambient: f32,\n  diffuse: f32,\n  shininess: f32,\n  specularColor: vec3<f32>,\n};\n\n@binding(2) @group(0) var<uniform> material : phongMaterialUniforms;\n\nfn lighting_getLightColor(surfaceColor: vec3<f32>, light_direction: vec3<f32>, view_direction: vec3<f32>, normal_worldspace: vec3<f32>, color: vec3<f32>) -> vec3<f32> {\n  let halfway_direction: vec3<f32> = normalize(light_direction + view_direction);\n  var lambertian: f32 = dot(light_direction, normal_worldspace);\n  var specular: f32 = 0.0;\n  if (lambertian > 0.0) {\n    let specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n    specular = pow(specular_angle, material.shininess);\n  }\n  lambertian = max(lambertian, 0.0);\n  return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;\n}\n\nfn lighting_getLightColor2(surfaceColor: vec3<f32>, cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32> {\n  var lightColor: vec3<f32> = surfaceColor;\n\n  if (lighting.enabled == 0) {\n    return lightColor;\n  }\n\n  let view_direction: vec3<f32> = normalize(cameraPosition - position_worldspace);\n  lightColor = material.ambient * surfaceColor * lighting.ambientColor;\n\n  if (lighting.lightType == 0) {\n    let pointLight: PointLight  = lighting_getPointLight(0);\n    let light_position_worldspace: vec3<f32> = pointLight.position;\n    let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);\n    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n  } else if (lighting.lightType == 1) {\n    var directionalLight: DirectionalLight = lighting_getDirectionalLight(0);\n    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n  }\n  \n  return lightColor;\n  /*\n  for (int i = 0; i < MAX_LIGHTS; i++) {\n    if (i >= lighting.pointLightCount) {\n      break;\n    }\n    PointLight pointLight = lighting.pointLight[i];\n    vec3 light_position_worldspace = pointLight.position;\n    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n  }\n\n  for (int i = 0; i < MAX_LIGHTS; i++) {\n    if (i >= lighting.directionalLightCount) {\n      break;\n    }\n    DirectionalLight directionalLight = lighting.directionalLight[i];\n    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n  }\n  */\n}\n\nfn lighting_getSpecularLightColor(cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32>{\n  var lightColor = vec3<f32>(0, 0, 0);\n  let surfaceColor = vec3<f32>(0, 0, 0);\n\n  if (lighting.enabled == 0) {\n    let view_direction = normalize(cameraPosition - position_worldspace);\n\n    switch (lighting.lightType) {\n      case 0, default: {\n        let pointLight: PointLight = lighting_getPointLight(0);\n        let light_position_worldspace: vec3<f32> = pointLight.position;\n        let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);\n        lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n      }\n      case 1: {\n        let directionalLight: DirectionalLight = lighting_getDirectionalLight(0);\n        lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n      }\n    }\n  }\n  return lightColor;\n}\n",vs:r.X,fs:r.l,defines:{LIGHTING_FRAGMENT:1},uniformTypes:{ambient:"f32",diffuse:"f32",shininess:"f32",specularColor:"vec3<f32>"},defaultUniforms:{ambient:.35,diffuse:.6,shininess:32,specularColor:[.15,.15,.15]},getUniforms(e){const t={...e};return t.specularColor&&(t.specularColor=t.specularColor.map((e=>e/255))),{...o.defaultUniforms,...t}}}},54663:(e,t,i)=>{i.d(t,{LF:()=>m});var n=i(35983);const r=/^[og]\s*(.+)?/,o=/^mtllib /,s=/^usemtl /;class a{constructor({index:e,name:t="",mtllib:i,smooth:n,groupStart:r}){this.index=e,this.name=t,this.mtllib=i,this.smooth=n,this.groupStart=r,this.groupEnd=-1,this.groupCount=-1,this.inherited=!1}clone(e=this.index){return new a({index:e,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0})}}class l{constructor(e=""){this.name=e,this.geometry={vertices:[],normals:[],colors:[],uvs:[]},this.materials=[],this.smooth=!0,this.fromDeclaration=null}startMaterial(e,t){const i=this._finalize(!1);i&&(i.inherited||i.groupCount<=0)&&this.materials.splice(i.index,1);const n=new a({index:this.materials.length,name:e,mtllib:Array.isArray(t)&&t.length>0?t[t.length-1]:"",smooth:void 0!==i?i.smooth:this.smooth,groupStart:void 0!==i?i.groupEnd:0});return this.materials.push(n),n}currentMaterial(){if(this.materials.length>0)return this.materials[this.materials.length-1]}_finalize(e){const t=this.currentMaterial();if(t&&-1===t.groupEnd&&(t.groupEnd=this.geometry.vertices.length/3,t.groupCount=t.groupEnd-t.groupStart,t.inherited=!1),e&&this.materials.length>1)for(let i=this.materials.length-1;i>=0;i--)this.materials[i].groupCount<=0&&this.materials.splice(i,1);return e&&0===this.materials.length&&this.materials.push({name:"",smooth:this.smooth}),t}}class c{constructor(){this.objects=[],this.object=null,this.vertices=[],this.normals=[],this.colors=[],this.uvs=[],this.materialLibraries=[],this.startObject("",!1)}startObject(e,t=!0){if(this.object&&!this.object.fromDeclaration)return this.object.name=e,void(this.object.fromDeclaration=t);const i=this.object&&"function"==typeof this.object.currentMaterial?this.object.currentMaterial():void 0;if(this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0),this.object=new l(e),this.object.fromDeclaration=t,i&&i.name&&"function"==typeof i.clone){const e=i.clone(0);e.inherited=!0,this.object.materials.push(e)}this.objects.push(this.object)}finalize(){this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0)}parseVertexIndex(e,t){const i=parseInt(e);return 3*(i>=0?i-1:i+t/3)}parseNormalIndex(e,t){const i=parseInt(e);return 3*(i>=0?i-1:i+t/3)}parseUVIndex(e,t){const i=parseInt(e);return 2*(i>=0?i-1:i+t/2)}addVertex(e,t,i){const n=this.vertices,r=this.object.geometry.vertices;r.push(n[e+0],n[e+1],n[e+2]),r.push(n[t+0],n[t+1],n[t+2]),r.push(n[i+0],n[i+1],n[i+2])}addVertexPoint(e){const t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])}addVertexLine(e){const t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])}addNormal(e,t,i){const n=this.normals,r=this.object.geometry.normals;r.push(n[e+0],n[e+1],n[e+2]),r.push(n[t+0],n[t+1],n[t+2]),r.push(n[i+0],n[i+1],n[i+2])}addColor(e,t,i){const n=this.colors,r=this.object.geometry.colors;r.push(n[e+0],n[e+1],n[e+2]),r.push(n[t+0],n[t+1],n[t+2]),r.push(n[i+0],n[i+1],n[i+2])}addUV(e,t,i){const n=this.uvs,r=this.object.geometry.uvs;r.push(n[e+0],n[e+1]),r.push(n[t+0],n[t+1]),r.push(n[i+0],n[i+1])}addUVLine(e){const t=this.uvs;this.object.geometry.uvs.push(t[e+0],t[e+1])}addFace(e,t,i,n,r,o,s,a,l){const c=this.vertices.length;let u=this.parseVertexIndex(e,c),h=this.parseVertexIndex(t,c),d=this.parseVertexIndex(i,c);if(this.addVertex(u,h,d),void 0!==n&&""!==n){const e=this.uvs.length;u=this.parseUVIndex(n,e),h=this.parseUVIndex(r,e),d=this.parseUVIndex(o,e),this.addUV(u,h,d)}if(void 0!==s&&""!==s){const e=this.normals.length;u=this.parseNormalIndex(s,e),h=s===a?u:this.parseNormalIndex(a,e),d=s===l?u:this.parseNormalIndex(l,e),this.addNormal(u,h,d)}this.colors.length>0&&this.addColor(u,h,d)}addPointGeometry(e){this.object.geometry.type="Points";const t=this.vertices.length;for(const i of e)this.addVertexPoint(this.parseVertexIndex(i,t))}addLineGeometry(e,t){this.object.geometry.type="Line";const i=this.vertices.length,n=this.uvs.length;for(const r of e)this.addVertexLine(this.parseVertexIndex(r,i));for(const r of t)this.addUVLine(this.parseUVIndex(r,n))}}var u=i(91532);function h(e,t){const i={};for(const r in t)"value"!==r&&(i[r]=JSON.stringify(t[r]));let{type:n}=(0,u.IT)(t.value);return 1===t.size||void 0===t.size||(n={type:"fixed-size-list",listSize:t.size,children:[{name:"values",type:n}]}),{name:e,type:n,nullable:!1,metadata:i}}function d(e,t){const{meshes:i}=function(e){const t=new c;-1!==e.indexOf("\r\n")&&(e=e.replace(/\r\n/g,"\n")),-1!==e.indexOf("\\\n")&&(e=e.replace(/\\\n/g,""));const i=e.split("\n");let n="",a="",l=0,u=[];const h="function"==typeof"".trimLeft;for(let c=0,g=i.length;c<g;c++)if(n=i[c],n=h?n.trimLeft():n.trim(),l=n.length,0!==l&&(a=n.charAt(0),"#"!==a))if("v"===a){const e=n.split(/\s+/);switch(e[0]){case"v":t.vertices.push(parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3])),e.length>=7&&t.colors.push(parseFloat(e[4]),parseFloat(e[5]),parseFloat(e[6]));break;case"vn":t.normals.push(parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3]));break;case"vt":t.uvs.push(parseFloat(e[1]),parseFloat(e[2]))}}else if("f"===a){const e=n.substr(1).trim().split(/\s+/),i=[];for(let t=0,n=e.length;t<n;t++){const n=e[t];if(n.length>0){const e=n.split("/");i.push(e)}}const r=i[0];for(let n=1,o=i.length-1;n<o;n++){const e=i[n],o=i[n+1];t.addFace(r[0],e[0],o[0],r[1],e[1],o[1],r[2],e[2],o[2])}}else if("l"===a){const e=n.substring(1).trim().split(" ");let i;const r=[];if(-1===n.indexOf("/"))i=e;else{i=[];for(let t=0,n=e.length;t<n;t++){const n=e[t].split("/");""!==n[0]&&i.push(n[0]),""!==n[1]&&r.push(n[1])}}t.addLineGeometry(i,r)}else if("p"===a){const e=n.substr(1).trim().split(" ");t.addPointGeometry(e)}else if(null!==(u=r.exec(n))){const e=(" "+u[0].substr(1).trim()).substr(1);t.startObject(e)}else if(s.test(n))t.object.startMaterial(n.substring(7).trim(),t.materialLibraries);else if(o.test(n))t.materialLibraries.push(n.substring(7).trim());else{if("s"!==a){if("\0"===n)continue;throw new Error(`Unexpected line: "${n}"`)}{if(u=n.split(" "),u.length>1){const e=u[1].trim().toLowerCase();t.object.smooth="0"!==e&&"off"!==e}else t.object.smooth=!0;const e=t.object.currentMaterial();e&&(e.smooth=t.object.smooth)}}t.finalize();const d=[],p=[];for(const r of t.objects){const{geometry:e}=r;if(0===e.vertices.length)continue;const t={header:{vertexCount:e.vertices.length/3},attributes:{}};switch(e.type){case"Points":t.mode=0;break;case"Line":t.mode=1;break;default:t.mode=4}t.attributes.POSITION={value:new Float32Array(e.vertices),size:3},e.normals.length>0&&(t.attributes.NORMAL={value:new Float32Array(e.normals),size:3}),e.colors.length>0&&(t.attributes.COLOR_0={value:new Float32Array(e.colors),size:3}),e.uvs.length>0&&(t.attributes.TEXCOORD_0={value:new Float32Array(e.uvs),size:2}),t.materials=[];for(const i of r.materials){const e={name:i.name,flatShading:!i.smooth};t.materials.push(e),p.push(e)}t.name=r.name,d.push(t)}return{meshes:d,materials:p}}(e),a=i.reduce(((e,t)=>e+t.header.vertexCount),0),l=function(e,t){const i=new Float32Array(3*t);let n,r,o,s=0;for(const l of e){const{POSITION:e,NORMAL:a,COLOR_0:c,TEXCOORD_0:u}=l.attributes;i.set(e.value,3*s),a&&(n=n||new Float32Array(3*t),n.set(a.value,3*s)),c&&(r=r||new Float32Array(3*t),r.set(c.value,3*s)),u&&(o=o||new Float32Array(2*t),o.set(u.value,2*s)),s+=e.value.length/3}const a={};a.POSITION={value:i,size:3},n&&(a.NORMAL={value:n,size:3});r&&(a.COLOR_0={value:r,size:3});o&&(a.TEXCOORD_0={value:o,size:2});return a}(i,a),u={vertexCount:a,boundingBox:(0,n.l)(l)},d=function(e,t={}){const i={};for(const r in t)"value"!==r&&(i[r]=JSON.stringify(t[r]));const n=[];for(const r in e){const t=h(r,e[r]);n.push(t)}return{fields:n,metadata:i}}(l,{mode:4,boundingBox:u.boundingBox});return{loaderData:{header:{}},schema:d,header:u,mode:4,topology:"point-list",attributes:l}}const p=/\s+/;function g(e,t){const i=[];let n={name:"placeholder"};const r=e.split("\n");for(let o of r){if(o=o.trim(),0===o.length||"#"===o.charAt(0))continue;const e=o.indexOf(" ");let t=e>=0?o.substring(0,e):o;t=t.toLowerCase();let r=e>=0?o.substring(e+1):"";switch(r=r.trim(),t){case"newmtl":n={name:r},i.push(n);break;case"ka":n.ambientColor=f(r);break;case"kd":n.diffuseColor=f(r);break;case"map_kd":n.diffuseTextureUrl=r;break;case"ks":n.specularColor=f(r);break;case"map_ks":n.specularTextureUrl=r;break;case"ke":n.emissiveColor=f(r);break;case"map_ke":n.emissiveTextureUrl=r;break;case"ns":n.shininess=parseFloat(r);break;case"map_ns":default:break;case"ni":n.refraction=parseFloat(r);break;case"illum":n.illumination=parseFloat(r)}}return i}function f(e,t){const i=e.split(p,3);return[parseFloat(i[0]),parseFloat(i[1]),parseFloat(i[2])]}const m={...{dataType:null,batchType:null,name:"OBJ",id:"obj",module:"obj",version:"4.3.2",worker:!0,extensions:["obj"],mimeTypes:["text/plain"],testText:function(e){return"v"===e[0]},options:{obj:{}}},parse:async(e,t)=>d((new TextDecoder).decode(e)),parseTextSync:(e,t)=>d(e)}},28453:(e,t,i)=>{i.d(t,{R:()=>s,x:()=>a});var n=i(96540);const r={},o=n.createContext(r);function s(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);